---
title: Crud
permalink: /docs/en/generate-crud
key: docs-generate-crud
---


This command generates the crud (***model***, ***controller***, ***migration***, ***form***, ***views***, ***seed***) for a particular model.

```php
php artisan administrable:make:crud {Model}
```

The ***--migrate*** or ***-m*** option is used to run artisan migrate command

```php
php artisan administrable:make:crud {Model} --migrate="true"
```

or

```php
php artisan administrable:make:crud {Model} --migrate="false"
```

**NB:**

The default value is *true*
{:.info}

To customize the generation, a configuration file ***administrable.yaml*** located at the root of the project is used. This file uses the **Yaml** language. If you do not know this syntax you can go [to the official website](https://www.yaml.org) to learn more.

Example of model declaration: ***Post***

```yaml
Post:
  name: { name: name, type: string, rules: nullable, slug: true }
  image: { name: image, type: image, rules: required }
  breadcrumb: name
  imagemanager:
    - front
    - back
    - images
```


## Overview

Only the name is required to declare a field (in some case).

```yaml
Post:
  name: { name: name }
```

However it can be optional if other keys are passed.

```yaml
Post:
  name: { type: string, rules: required }
```

## Field types

```yaml
Post:
  name: {  type: string }
```

The default type is: ***string***

Available types are: **string, text, mediumText, longText, date, datetime, boolean, enum, decimal, float, double, integer, mediumInteger, bigInteger, polymorphic, ipAdress, image, relation, file**

For file type  you can use either *file* or *image* (just an alias)
{:.info}

```yaml
Post:
  name: { type: file } # or { type: image }
```

## Polymorphic type

To create a polymorphic field

```yaml
Post:
  name: { type: string, rules: required, type: polymorphic }
```

or

```yaml
Post:
  name: { rules: required, polymorphic: true }
```

The name of the polymorphic relation is the name of the field with the suffix ***able*** by default. This behavior can be modified with:

```yaml
Post:
  image:
    type: image
    name: mediaable
    rules: required
```

Polymorphic field names can be changed with

```yaml
Post:
  image:
    type: image
    model_id: imageable_id
    model_type: imageable_type
    rules: required
```

The *model_id* must have the suffix ***_ id*** and the *model_type* must have the suffix ***_ type***

## Form

You can pass valid html5 attributes to the form that will be generated

```yaml
User:
  facebook: { type: string, form: { id: form_id, class: class_name, type: url } }
```

supported attributes are *id*, *class* , *pattern*, *type*, *readonly*, *disabled*
{:.info}

## Cast

Attribute casting allow you to transform Eloquent attribute values when you retrieve or set them on models instances.

```yaml
User:
  age: { type: integer, cast: integer }
```

boolean and datetime types are automatically cast
{:.info}

## Datepicker

Add datepicker for date type fields.

```yaml
User:
  age: { datepicker: true }
```

only date type fields can have a datepicker
{:.info}
## Daterange

For a date range type field, two fields will be created to represent the start field and the end field respectively with the suffix ***start_at*** and ***end_at***. Suffixes can be changed in the configuration file.

```yaml
User:
  promotion: { type: datetime,  daterange: true }
```

only date type fields can have a datepicker
{:.info}

## Validation

The validation rules are passed by the key ***rules*** and by default is an empty string.

```yaml
Post:
  name: { rules: required }
```

It uses the default validation rules of [laravel validation](https://laravel.com/docs/validation).

Several rules must be separated by the pipe  **\|** character
{:.info}

```yaml
Post:
  name: { rules: required|string|min:2 }
```

for  ***required*** rule we can use the diminutive ***req*** (just an alias)
{:.info}

```yaml
Post:
  name: { rules: req|string|min:2 }
```

## Nullable

To make a field nullable

```yaml
Post:
  name: {  nullable: true }
```

or use the nullable validation rule

```yaml
Post:
  name: { rules: nullable }
```

If a field has the nullable validation rule, the field is automatically nullable.
If a field is nullable then it automatically has the nullable validation rule.
No need to specify it twice.
{:.info}

## Length

To define the length of a field

```yaml
Post:
  name: { length: 60 }
```

For the ***string*** (*text*, *mediumText*, *longText*) or ***int*** (*int*, *smallInt*, *BigInt*)  types,  you can pass the size of the field to the type separate by ***:***

```yaml
Post:
  name: { type: string:60  }
```

```yaml
User:
  age: { type: int:18 }
```

## Table name

To change  database table name
```yaml
Post:
  table_name: posts
```


## Slug

To sluggify a field and use slug instead of id for routes

```yaml
Post:
  name: { slug: true }
```

or pass the slug option at the model level with the name of the field to be sluggified which must be defined beforehand (***important***).

```yaml
Post:
  name: { name: name, type: string:125, rules: nullable }
  age: { type: int:3 }
  slug: name
```

**NB:**
- one of the two options can  be used.
- only one field can be sluggable
- only  (***text***, ***longText***, ***mediumText***) fields can be sluggify


## Edit slug

To have the slug field in form and edit it

```yaml
Post:
  name: { slug: true }
  edit_slug: true
```

Or use it globally. This will affect all models

```yaml
edit_slug: true
```

**NB:**
- The default value is *false*.
- A slug field is required on the model

## Clone

To have a button in index view to clone or duplicate a field

```yaml
Post:
  name: { slug: true }
  clone: true
```

Or use it globally. This will affect all models

```yaml
clone: true
```

The default value is *true*
{:.info}

## Fillable

To use fillable or guarded property in the model

```yaml
Post:
  name: { slug: true }
  fillable: true
```

Or use it globally. This will affect all models

```yaml
fillable: true
```

The default value is *true*
{:.info}

## Tranlation

The model can be translated with the *trans* option

```yaml
Post:
  name: { name: name, type: string:125, rules: nullable }
  age: { type: int:3 }
  trans: article
```

A field can be translated too.

```yaml
Post:
  name: { trans: nom }
```

For date range field, you must separate the translation field with the **\|** (pipe) character.


```yaml
Post:
  promotion: { type: datetime, daterange: true, trans: promotion start | promotion end }
```

This translation is only used for displaying in views.
If the option is not passed, the translation file in  **resources/lang**  in the current locale folder will be used.
{:.info}

## Default value

Set default value

```yaml
Post:
  name: { default: john }
```

## Actions

Sometimes we do not want to generate all crud actions *(index, show, create, edit, delete)*.

The authorized values are: ***index***, ***show***, ***create***, ***edit*** and ***delete***
{:.info}

Actions can be separated by a , (*comma*)

```yaml
Post:
  actions: index,show,create,edit,delete
```

Actions can be separated by the character pipe **\|**

```yaml
Post:
  actions: index|show|create|edit|delete
```

Actions can be declared as a list

```yaml
Post:
  actions:
    - index
    - show
    - create
    - edit
    - delete
```

## Tinymce

To use the tinymce rich editor for a field

```yaml
Post:
  name: { tinymce: true }
```

## Timestamps

By default for each model laravel manages the *created_at* and *updated_at* fields.
To deactivate it you can proceed as follows:

```yaml
Post:
  timestamps: false
```

It will add on the model the attribute

```php
protected $timestamps = false;
```

## Imagemanger

To use the image manager for a specific model.

A model can only use 03 collections (*front*, *back* and *images*)
{:.info}

To use all collections and default labels

```yaml
Post:
  imagemanager: true
```

You can choose the collection (s) to use

```yaml
Post:
    imagemanager:
      - front
      - back
      - images
```

Labels can be changed this way

With the comma syntax

```yaml
Post:
  imagemanager: { front: front image label, back: back image label, images: images label }
```

or with the other syntax

```yaml
Post:
    imagemanager:
      front: front image label
      back: back image label
      images: images label
```

## Icon

To change the icon used in the administration sidebar.

```yaml
Post:
  name: { name: name,trans: nom, default: john }
  icon: fa-folder
```

**NB**:
- The icon must be taken from the font awesome library.
- The default value is fa-folder

## Entity
To generate only model and migration, you will have to use the *entity* tag on model's definition.

```yaml
Post:
  name: { rules: required }
  entity: true
```

## Constraints

```yaml
Post:
  name: { constraints: nullable }
```

Constraints can be separated by  a comma *,*

```yaml
Post:
  name: { constraints: nullable,unique,index}
```

or with the list syntax

```yaml
Post:
  name:
    constraints:
       - nullable
       - unique
       - index
```

**NB**:
- The constraints must be valid according to the database management system.
- For the constraint ***set null***, no need to pass the field to ***nullable***. Itâ€™s done automatically.
- On the other hand, do not forget to remove the validation rule ***required*** if it is present because a field cannot be both ***required*** and ***nullable***.
- If the field is ***nullable*** no need to put it in the list of constraints and vice versa.
- For the ***default*** constraint  the value can be passed with **:**

```yaml
Post:
  age: { constraints: default:18 }
```

## Seeder

To avoid generating a seeder file

```yaml
Post:
  age: { constraints: default:18 }
  seeder: false
```

## breadcrumb

For showing breadcrumb in views, the procedure is as follows:

```yaml
Post:
  age: { breadcrumb: true }
```

or pass the breadcrumb option at the model level with the name of the field to use

```yaml
Post:
  age: { name: age}
  breadcrumb: age
```

**NB**
- only one of the two possibilities can be used
- only one field can have this breadcrumb attribute
- the breadcrumb is only used in administration panel

## Relationships

For relations the type ***relation*** is used

```yaml
Post:
  user_id: { type: relation, related: user }
```

The related is optional, we guest the name by remove the *_id*  on the field's name.
If the field doest not respect this convention, you have to use this option.

```yaml
Post:
  user_id: { type: relation }
```

In this case, the related will be **User**.

It is possible to use the full qualify model class name.

```yaml
Post:
  user_id: { type: relation, related: App\Models\User }
```
You can change the key used for the foreign key.

```yaml
Post:
  user_id: { type: { relation: one to one, type: simple, related: user, property: name, references: id }, rules: required }
```
By default id is used
{:.info}

You can change the deletion policy.

```yaml
Post:
  user_id: { type: { relation: one to one, type: simple, related: user, property: name, onDelete: cascade }, rules: required }
```

**NB:**
- the authorized values are: ***cascade*** and ***set null***.
- no onDelete on a polymorphic type field.
- if a field must be polymorphic it will be necessary to create the linked model first before making the connection
- for relationship type fields if the related is not passed it is the name of the field which is used


## Type simple

### One to One (simple)

```yaml
Post:
  user_id: { type: { relation: one to one, type: simple, related: user, property: name }, rules: required }
```

**NB:**

- The related is obligatory we must know to which field the relation is linked
- The related is mandatory and is the linked model. We can just pass the name
or the namespace.
- The property is the field used only for display and must exist on the linked model.

### Foreign keys

For the model we are going to create

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      local_keys: { foreign_key: kguy_id, local_key: kid }
    rules: required
```

For the model to be linked

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      related_keys:  { foreign_key: guy_id, other_key: id }
    rules: required
```

### One to Many (simple)

```yaml
Post:
  user_id: { type: { relation: one to many, type: simple, related: user, property: name }, rules: required }
```

**NB:**

- the related is obligatory (we must know to which field the relation is linked)
- the related is mandatory and is the linked model. We can just pass the name or the full namespace.
- the property is the field used only for display and must exist on the linked model.

### Foreign keys

For the model we are going to create

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      local_keys: { foreign_key: kguy_id, local_key: kid }
    rules: required
```

- For the model that will be linked

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      related_keys:  { foreign_key: guy_id, other_key: id }
    rules: required
```

**Many to Many (simple)**

```yaml
Post:
  user_id: { type: { relation: many to many, type: simple, related: user, property: name }, rules: required }
```

**NB:**

- the pivot table is automatically generated.
- you can change the name of the pivot intermediate table.

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
    rules: required
```

### Foreign keys

- For the model we are going to create

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      local_keys: { foreign_key: terrain_id, join_key: user_id }
    rules: required
```

- For the model that will be linked

```yaml
Post:
  user_id:
    type:
      relation: many to many
      type: simple
      related: user
      property: name
      intermediate_table: post_user
      related_keys: { foreign_key: user_id, join_key: terrain_id }
    rules: required
```

If the keys are passed and the intermediate table (pivot) is not then this table will be created with the convention.

### One to One (polymorphic)

```yaml
Post:
  user_id:
    type:
      relation: one to one
      type: polymorphic
      related: user
      property: name
    rules: required
```

### One to Many (polymorphic)

```yaml
Post:
  user_id:
    type:
      relation: one to many
      type: polymorphic
      related: user
      property: name
    rules: required
```

### Many to Many polymorphic

The ***many to many*** polymorphic relationship is not yet established. I haven't had to use it in my various projects yet.
Maybe soon.

